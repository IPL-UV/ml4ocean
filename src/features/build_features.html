<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>src.features.build_features API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.features.build_features</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from typing import List, Optional
import geopandas as gpd
import pandas as pd
from shapely.geometry import Point, Polygon
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.compose import ColumnTransformer
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import FunctionTransformer
from sklearn.pipeline import Pipeline

# Datasets
from src.data.make_dataset import (
    DataLoader,
    load_standard_data,
    load_high_dim_data,
    load_labels,
)


class ProcessParams:
    n_components = 5
    valid_split = 0.2
    standardize = &#34;before&#34;
    seed = 123
    bootstrap_seed = 123


class CycleTransform(BaseEstimator, TransformerMixin):
    &#34;&#34;&#34;Converts some times to a cyclic axis of x, y using sin and cos. 
    
    
    1. Converts the times to radians 
    2. Normalizes by the maximum of the time cycle
    3. Applies the sin and cosine transformation
    4. Drops original columns

    Parameters 
    ----------
    time_types : List of , e.g. [&#39;doy&#39;, &#39;month&#39;, &#39;hour&#39;]
        The time type to convert to a cycle
        doy - assumes 1 in 24 hours

    Example
    -------
    &gt;&gt; times = [&#39;doy&#39;]
    &gt;&gt; X = CycleTransform(times).fit_transform(X)

    &gt;&gt; times = [&#39;doy&#39;, &#39;month&#39;]
    &gt;&gt; X = CycleTransform(times).fit_transform(X)
    &#34;&#34;&#34;

    def __init__(self, time_types: List[str] = [&#34;doy&#34;]):
        self.time_types = time_types

    def fit(self, X, y=None):
        &#34;&#34;&#34;For compatibility reasons.&#34;&#34;&#34;
        return self

    def transform(self, X: pd.DataFrame, y: Optional[pd.DataFrame] = None):
        &#34;&#34;&#34;
        Parameters 
        ----------
        X : pd.DataFrame
            A dataframe with the values. The columns need to be one of the following
            [&#39;doy&#39;, &#39;month&#39;, &#39;hour&#39;]
        
        y : pd.DataFrame, Optional
            Does nothing. Only for compatibility reasons.
        
        Returns
        -------
        df : pd.DataFrame
            A dataframe with the converted values.
        &#34;&#34;&#34;
        deg2rad = 2 * np.pi

        cols = X.columns.tolist()

        if &#34;doy&#34; in self.time_types and &#34;doy&#34; in cols:

            const = 365.0  # number of days in a year

            X[&#34;doy_sin&#34;] = np.sin(X[&#34;doy&#34;] * deg2rad / const)
            X[&#34;doy_cos&#34;] = np.cos(X[&#34;doy&#34;] * deg2rad / const)

            X = X.drop(&#34;doy&#34;, axis=1)

        if &#34;month&#34; in self.time_types and &#34;month&#34; in cols:

            const = 12  # number of months in a year

            X[&#34;month_sin&#34;] = np.sin((X[&#34;month&#34;] - 1) * deg2rad / const)
            X[&#34;month_cos&#34;] = np.cos((X[&#34;month&#34;] - 1) * deg2rad / const)

            X = X.drop(&#34;month&#34;, axis=1)

        if &#34;hour&#34; in self.time_types and &#34;hour&#34; in cols:

            const = 24.0  # number of days in a year

            X[&#34;hour_sin&#34;] = np.sin(X[&#34;hour&#34;] * deg2rad / const)
            X[&#34;hour_cos&#34;] = np.cos(X[&#34;hour&#34;] * deg2rad / const)

            X = X.drop(&#34;hour&#34;, axis=1)

        # drop original column

        return X


class GeoCartTransform(BaseEstimator, TransformerMixin):
    &#34;&#34;&#34;Transforms geo coordinates (lat, lon) to cartesian coordinates
    (x, y, z).
    
    Example
    -------
    &gt;&gt; df = geo_2_cartesian(df)
    &#34;&#34;&#34;

    def __init__(self):
        pass

    def fit(self, X: pd.DataFrame, y: Optional[pd.DataFrame] = None):
        return self

    def transform(self, X: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;    
        Parameters 
        ----------
        df : pd.DataFrame
            A dataframe with the geo coordinates values. The columns need to 
            have the following [&#39;lat&#39;, &#39;lon]
        
        Returns
        -------
        df : pd.DataFrame
            A dataframe with the converted values.
        &#34;&#34;&#34;
        cols = X.columns.tolist()

        if &#34;lat&#34; not in cols or &#34;lon&#34; not in cols:
            print(&#34;lat,lon columns not present in X.&#34;)
            return X

        deg2rad = np.pi / 180.0

        # transform from degrees to radians
        X[&#34;lat&#34;] *= deg2rad
        X[&#34;lon&#34;] *= deg2rad

        # From Geo coords to cartesian coords
        X[&#34;x&#34;] = np.cos(X[&#34;lat&#34;]) * np.cos(X[&#34;lon&#34;])
        X[&#34;y&#34;] = np.cos(X[&#34;lat&#34;]) * np.sin(X[&#34;lon&#34;])
        X[&#34;z&#34;] = np.sin(X[&#34;lat&#34;])

        # drop original columns
        X = X.drop([&#34;lat&#34;, &#34;lon&#34;], axis=1)

        return X


def get_geodataframe(dataframe: pd.DataFrame) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;This function will transform the dataset from a 
    pandas.DataFrame to a geopandas.DataFrame which will
    have a special column for geometry. This will make plotting 
    a lot easier.&#34;&#34;&#34;
    # get polygons
    geometry = [Point(xy) for xy in zip(dataframe[&#34;lon&#34;], dataframe[&#34;lat&#34;])]

    # coordinate systems
    crs = {&#34;init&#34;: &#34;epsg:4326&#34;}

    # create dataframe
    gpd_df = gpd.GeoDataFrame(dataframe, crs=crs, geometry=geometry)
    return gpd_df


def geo_2_cartesian(df: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Transforms geo coordinates (lat, lon) to cartesian coordinates
    (x, y, z).
    
    Parameters 
    ----------
    df : pd.DataFrame
        A dataframe with the geo coordinates values. The columns need to 
        have the following [&#39;lat&#39;, &#39;lon]
    
    Returns
    -------
    df : pd.DataFrame
        A dataframe with the converted values.

    Example
    -------
    &gt;&gt; df = geo_2_cartesian(df)
    &#34;&#34;&#34;
    cols = df.columns.tolist()

    if &#34;lat&#34; not in cols or &#34;lon&#34; not in cols:
        print(&#34;lat,lon columns not present in df.&#34;)
        return df

    deg2rad = np.pi / 180.0

    # transform from degrees to radians
    df[&#34;lat&#34;] *= deg2rad
    df[&#34;lon&#34;] *= deg2rad

    # From Geo coords to cartesian coords
    df[&#34;x&#34;] = np.cos(df[&#34;lat&#34;]) * np.cos(df[&#34;lon&#34;])
    df[&#34;y&#34;] = np.cos(df[&#34;lat&#34;]) * np.sin(df[&#34;lon&#34;])
    df[&#34;z&#34;] = np.sin(df[&#34;lat&#34;])

    # drop original columns
    df = df.drop([&#34;lat&#34;, &#34;lon&#34;], axis=1)

    return df


def times_2_cycles(df: pd.DataFrame, time_types: List[str] = [&#34;doy&#34;]) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Converts some times to a cyclic axis of x, y using sin and cos. 
    
    
    1. Converts the times to radians 
    2. Normalizes by the maximum of the time cycle
    3. Applies the sin and cosine transformation
    4. Drops original columns

    Parameters 
    ----------
    df : pd.DataFrame
        A dataframe with the values. The columns need to be one of the following
        [&#39;doy&#39;, &#39;month&#39;, &#39;hour&#39;]
    
    time_types : List of , e.g. [&#39;doy&#39;, &#39;month&#39;, &#39;hour&#39;]
        The time type to convert to a cycle
        doy - assumes 1 in 24 hours
    
    Returns
    -------
    df : pd.DataFrame
        A dataframe with the converted values.

    Example
    -------
    &gt;&gt; times = [&#39;doy&#39;]
    &gt;&gt; df = time_2_cycle(df, times)

    &gt;&gt; times = [&#39;doy&#39;, &#39;month&#39;]
    &gt;&gt; df = times_2_cycles(df, times)
    &#34;&#34;&#34;
    deg2rad = 2 * np.pi

    cols = X.columns.tolist()

    if &#34;doy&#34; in time_types and &#34;doy&#34; in cols:

        const = 365.0  # number of days in a year

        df[&#34;doy_sin&#34;] = np.sin(df[&#34;doy&#34;] * deg2rad / const)
        df[&#34;doy_cos&#34;] = np.cos(df[&#34;doy&#34;] * deg2rad / const)

        df = df.drop(&#34;doy&#34;, axis=1)

    if &#34;month&#34; in time_types and &#34;month&#34; in cols:

        const = 12  # number of months in a year

        df[&#34;month_sin&#34;] = np.sin((df[&#34;month&#34;] - 1) * deg2rad / const)
        df[&#34;month_cos&#34;] = np.cos((df[&#34;month&#34;] - 1) * deg2rad / const)

        df = df.drop(&#34;month&#34;, axis=1)

    if &#34;hour&#34; in time_types and &#34;hour&#34; in cols:

        const = 24.0  # number of days in a year

        df[&#34;hour_sin&#34;] = np.sin(df[&#34;hour&#34;] * deg2rad / const)
        df[&#34;hour_cos&#34;] = np.cos(df[&#34;hour&#34;] * deg2rad / const)

        df = df.drop(&#34;hour&#34;, axis=1)

    # drop original column

    return df


def run_input_preprocess(params, dataset):

    # get columns
    dataloader = DataLoader()

    columns = dataloader.load_columns()

    new_columns = [
        *[&#34;doy_cos&#34;, &#34;doy_sin&#34;],
        *[&#34;x&#34;, &#34;y&#34;, &#34;z&#34;],
        *[f&#34;temperature_pc{icomponent+1}&#34; for icomponent in range(params.n_components)],
        *[f&#34;density_pc{icomponent+1}&#34; for icomponent in range(params.n_components)],
        *[f&#34;salinity_pc{icomponent+1}&#34; for icomponent in range(params.n_components)],
        *[f&#34;spicy_pc{icomponent+1}&#34; for icomponent in range(params.n_components)],
        *columns[&#34;core&#34;],
    ]
    # print(columns[&#34;temperature&#34;])
    # define transfomer
    if params.input_std == &#34;before&#34;:
        X_pre_transformer = ColumnTransformer(
            [
                (&#34;time&#34;, CycleTransform(columns[&#34;time&#34;]), columns[&#34;time&#34;]),
                (&#34;location&#34;, GeoCartTransform(), columns[&#34;location&#34;]),
                (
                    &#34;temperature&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;temperature&#34;],
                ),
                (
                    &#34;density&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;density&#34;],
                ),
                (
                    &#34;salinity&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;salinity&#34;],
                ),
                (
                    &#34;spicy&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;spicy&#34;],
                ),
                (
                    &#34;core&#34;,
                    StandardScaler(with_mean=True, with_std=True),
                    columns[&#34;core&#34;],
                ),
            ],
            remainder=&#34;passthrough&#34;,
        )
    elif params.input_std == &#34;after&#34;:
        X_pre_transformer = ColumnTransformer(
            [
                (&#34;time&#34;, CycleTransform(columns[&#34;time&#34;]), columns[&#34;time&#34;]),
                (&#34;location&#34;, GeoCartTransform(), columns[&#34;location&#34;]),
                (
                    &#34;temperature&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;temperature&#34;],
                ),
                (
                    &#34;density&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;density&#34;],
                ),
                (
                    &#34;salinity&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;salinity&#34;],
                ),
                (
                    &#34;spicy&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;spicy&#34;],
                ),
            ],
            remainder=&#34;passthrough&#34;,
        )
    else:
        raise ValueError(f&#34;Unrecognized standardize param: {params.standardize}&#34;)

    # transform data
    t = X_pre_transformer.fit_transform(dataset[&#34;Xtrain&#34;])
    dataset[&#34;Xtrain&#34;] = X_pre_transformer.fit_transform(dataset[&#34;Xtrain&#34;])
    dataset[&#34;Xtest&#34;] = X_pre_transformer.transform(dataset[&#34;Xtest&#34;])
    dataset[&#34;input_pre_trans&#34;] = X_pre_transformer
    dataset[&#34;new_columns&#34;] = new_columns
    return dataset


def run_input_postprocess(params, dataset):

    # initialize transfomer

    X_post_transformer = StandardScaler(with_mean=True, with_std=True)

    # data

    dataset[&#34;Xtrain&#34;] = X_post_transformer.fit_transform(dataset[&#34;Xtrain&#34;])
    dataset[&#34;Xtest&#34;] = X_post_transformer.transform(dataset[&#34;Xtest&#34;])
    dataset[&#34;Xvalid&#34;] = X_post_transformer.transform(dataset[&#34;Xvalid&#34;])
    dataset[&#34;input_post_trans&#34;] = X_post_transformer
    return dataset


def run_output_preprocess(params, dataset):

    # data = {}
    # dataset[&#34;ytrain&#34;] = np.log(dataset[&#34;ytrain&#34;])
    # dataset[&#34;ytest&#34;] = np.log(dataset[&#34;ytest&#34;])
    # dataset[&#34;out_pre_trans&#34;] = np.log
    return dataset


def run_output_postprocess(params, dataset):

    if params.std_ouputs == True:

        def loginv(x):
            return 10 ** x

        dataset[&#34;out_post_trans&#34;] = Pipeline(
            [
                (&#34;log&#34;, FunctionTransformer(func=np.log10, inverse_func=loginv)),
                (&#34;scale&#34;, StandardScaler()),
            ]
        )
    elif params.std_ouputs == False:
        dataset[&#34;out_post_trans&#34;] = Pipeline([(&#34;scale&#34;, StandardScaler())])
    else:
        raise ValueError(f&#34;Unrecognized params.std_ouputs: {params.std_ouputs}&#34;)

    columns = dataset[&#34;ytrain&#34;].columns

    dataset[&#34;ytrain&#34;] = pd.DataFrame(
        dataset[&#34;out_post_trans&#34;].fit_transform(dataset[&#34;ytrain&#34;]), columns=columns
    )
    dataset[&#34;ytest&#34;] = pd.DataFrame(
        dataset[&#34;out_post_trans&#34;].transform(dataset[&#34;ytest&#34;]), columns=columns
    )
    dataset[&#34;yvalid&#34;] = pd.DataFrame(
        dataset[&#34;out_post_trans&#34;].transform(dataset[&#34;yvalid&#34;]), columns=columns
    )

    return dataset


def run_split(params, dataset):
    Xtrain, Xvalid, ytrain, yvalid = train_test_split(
        dataset[&#34;Xtrain&#34;],
        dataset[&#34;ytrain&#34;],
        train_size=1 - params.valid_split,
        random_state=params.bootstrap_seed,
    )

    dataset[&#34;Xtrain&#34;] = Xtrain
    dataset[&#34;Xvalid&#34;] = Xvalid
    dataset[&#34;ytrain&#34;] = ytrain
    dataset[&#34;yvalid&#34;] = yvalid
    return dataset</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.features.build_features.geo_2_cartesian"><code class="name flex">
<span>def <span class="ident">geo_2_cartesian</span></span>(<span>df: pandas.core.frame.DataFrame) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms geo coordinates (lat, lon) to cartesian coordinates
(x, y, z).</p>
<h2 id="parameters">Parameters</h2>
<p>df : pd.DataFrame
A dataframe with the geo coordinates values. The columns need to
have the following ['lat', 'lon]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A dataframe with the converted values.</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<p>df = geo_2_cartesian(df)</p>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geo_2_cartesian(df: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Transforms geo coordinates (lat, lon) to cartesian coordinates
    (x, y, z).
    
    Parameters 
    ----------
    df : pd.DataFrame
        A dataframe with the geo coordinates values. The columns need to 
        have the following [&#39;lat&#39;, &#39;lon]
    
    Returns
    -------
    df : pd.DataFrame
        A dataframe with the converted values.

    Example
    -------
    &gt;&gt; df = geo_2_cartesian(df)
    &#34;&#34;&#34;
    cols = df.columns.tolist()

    if &#34;lat&#34; not in cols or &#34;lon&#34; not in cols:
        print(&#34;lat,lon columns not present in df.&#34;)
        return df

    deg2rad = np.pi / 180.0

    # transform from degrees to radians
    df[&#34;lat&#34;] *= deg2rad
    df[&#34;lon&#34;] *= deg2rad

    # From Geo coords to cartesian coords
    df[&#34;x&#34;] = np.cos(df[&#34;lat&#34;]) * np.cos(df[&#34;lon&#34;])
    df[&#34;y&#34;] = np.cos(df[&#34;lat&#34;]) * np.sin(df[&#34;lon&#34;])
    df[&#34;z&#34;] = np.sin(df[&#34;lat&#34;])

    # drop original columns
    df = df.drop([&#34;lat&#34;, &#34;lon&#34;], axis=1)

    return df</code></pre>
</details>
</dd>
<dt id="src.features.build_features.get_geodataframe"><code class="name flex">
<span>def <span class="ident">get_geodataframe</span></span>(<span>dataframe: pandas.core.frame.DataFrame) -> geopandas.geodataframe.GeoDataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>This function will transform the dataset from a
pandas.DataFrame to a geopandas.DataFrame which will
have a special column for geometry. This will make plotting
a lot easier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_geodataframe(dataframe: pd.DataFrame) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;This function will transform the dataset from a 
    pandas.DataFrame to a geopandas.DataFrame which will
    have a special column for geometry. This will make plotting 
    a lot easier.&#34;&#34;&#34;
    # get polygons
    geometry = [Point(xy) for xy in zip(dataframe[&#34;lon&#34;], dataframe[&#34;lat&#34;])]

    # coordinate systems
    crs = {&#34;init&#34;: &#34;epsg:4326&#34;}

    # create dataframe
    gpd_df = gpd.GeoDataFrame(dataframe, crs=crs, geometry=geometry)
    return gpd_df</code></pre>
</details>
</dd>
<dt id="src.features.build_features.run_input_postprocess"><code class="name flex">
<span>def <span class="ident">run_input_postprocess</span></span>(<span>params, dataset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_input_postprocess(params, dataset):

    # initialize transfomer

    X_post_transformer = StandardScaler(with_mean=True, with_std=True)

    # data

    dataset[&#34;Xtrain&#34;] = X_post_transformer.fit_transform(dataset[&#34;Xtrain&#34;])
    dataset[&#34;Xtest&#34;] = X_post_transformer.transform(dataset[&#34;Xtest&#34;])
    dataset[&#34;Xvalid&#34;] = X_post_transformer.transform(dataset[&#34;Xvalid&#34;])
    dataset[&#34;input_post_trans&#34;] = X_post_transformer
    return dataset</code></pre>
</details>
</dd>
<dt id="src.features.build_features.run_input_preprocess"><code class="name flex">
<span>def <span class="ident">run_input_preprocess</span></span>(<span>params, dataset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_input_preprocess(params, dataset):

    # get columns
    dataloader = DataLoader()

    columns = dataloader.load_columns()

    new_columns = [
        *[&#34;doy_cos&#34;, &#34;doy_sin&#34;],
        *[&#34;x&#34;, &#34;y&#34;, &#34;z&#34;],
        *[f&#34;temperature_pc{icomponent+1}&#34; for icomponent in range(params.n_components)],
        *[f&#34;density_pc{icomponent+1}&#34; for icomponent in range(params.n_components)],
        *[f&#34;salinity_pc{icomponent+1}&#34; for icomponent in range(params.n_components)],
        *[f&#34;spicy_pc{icomponent+1}&#34; for icomponent in range(params.n_components)],
        *columns[&#34;core&#34;],
    ]
    # print(columns[&#34;temperature&#34;])
    # define transfomer
    if params.input_std == &#34;before&#34;:
        X_pre_transformer = ColumnTransformer(
            [
                (&#34;time&#34;, CycleTransform(columns[&#34;time&#34;]), columns[&#34;time&#34;]),
                (&#34;location&#34;, GeoCartTransform(), columns[&#34;location&#34;]),
                (
                    &#34;temperature&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;temperature&#34;],
                ),
                (
                    &#34;density&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;density&#34;],
                ),
                (
                    &#34;salinity&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;salinity&#34;],
                ),
                (
                    &#34;spicy&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;spicy&#34;],
                ),
                (
                    &#34;core&#34;,
                    StandardScaler(with_mean=True, with_std=True),
                    columns[&#34;core&#34;],
                ),
            ],
            remainder=&#34;passthrough&#34;,
        )
    elif params.input_std == &#34;after&#34;:
        X_pre_transformer = ColumnTransformer(
            [
                (&#34;time&#34;, CycleTransform(columns[&#34;time&#34;]), columns[&#34;time&#34;]),
                (&#34;location&#34;, GeoCartTransform(), columns[&#34;location&#34;]),
                (
                    &#34;temperature&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;temperature&#34;],
                ),
                (
                    &#34;density&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;density&#34;],
                ),
                (
                    &#34;salinity&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;salinity&#34;],
                ),
                (
                    &#34;spicy&#34;,
                    PCA(n_components=params.n_components, random_state=params.pca_seed),
                    columns[&#34;spicy&#34;],
                ),
            ],
            remainder=&#34;passthrough&#34;,
        )
    else:
        raise ValueError(f&#34;Unrecognized standardize param: {params.standardize}&#34;)

    # transform data
    t = X_pre_transformer.fit_transform(dataset[&#34;Xtrain&#34;])
    dataset[&#34;Xtrain&#34;] = X_pre_transformer.fit_transform(dataset[&#34;Xtrain&#34;])
    dataset[&#34;Xtest&#34;] = X_pre_transformer.transform(dataset[&#34;Xtest&#34;])
    dataset[&#34;input_pre_trans&#34;] = X_pre_transformer
    dataset[&#34;new_columns&#34;] = new_columns
    return dataset</code></pre>
</details>
</dd>
<dt id="src.features.build_features.run_output_postprocess"><code class="name flex">
<span>def <span class="ident">run_output_postprocess</span></span>(<span>params, dataset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_output_postprocess(params, dataset):

    if params.std_ouputs == True:

        def loginv(x):
            return 10 ** x

        dataset[&#34;out_post_trans&#34;] = Pipeline(
            [
                (&#34;log&#34;, FunctionTransformer(func=np.log10, inverse_func=loginv)),
                (&#34;scale&#34;, StandardScaler()),
            ]
        )
    elif params.std_ouputs == False:
        dataset[&#34;out_post_trans&#34;] = Pipeline([(&#34;scale&#34;, StandardScaler())])
    else:
        raise ValueError(f&#34;Unrecognized params.std_ouputs: {params.std_ouputs}&#34;)

    columns = dataset[&#34;ytrain&#34;].columns

    dataset[&#34;ytrain&#34;] = pd.DataFrame(
        dataset[&#34;out_post_trans&#34;].fit_transform(dataset[&#34;ytrain&#34;]), columns=columns
    )
    dataset[&#34;ytest&#34;] = pd.DataFrame(
        dataset[&#34;out_post_trans&#34;].transform(dataset[&#34;ytest&#34;]), columns=columns
    )
    dataset[&#34;yvalid&#34;] = pd.DataFrame(
        dataset[&#34;out_post_trans&#34;].transform(dataset[&#34;yvalid&#34;]), columns=columns
    )

    return dataset</code></pre>
</details>
</dd>
<dt id="src.features.build_features.run_output_preprocess"><code class="name flex">
<span>def <span class="ident">run_output_preprocess</span></span>(<span>params, dataset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_output_preprocess(params, dataset):

    # data = {}
    # dataset[&#34;ytrain&#34;] = np.log(dataset[&#34;ytrain&#34;])
    # dataset[&#34;ytest&#34;] = np.log(dataset[&#34;ytest&#34;])
    # dataset[&#34;out_pre_trans&#34;] = np.log
    return dataset</code></pre>
</details>
</dd>
<dt id="src.features.build_features.run_split"><code class="name flex">
<span>def <span class="ident">run_split</span></span>(<span>params, dataset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_split(params, dataset):
    Xtrain, Xvalid, ytrain, yvalid = train_test_split(
        dataset[&#34;Xtrain&#34;],
        dataset[&#34;ytrain&#34;],
        train_size=1 - params.valid_split,
        random_state=params.bootstrap_seed,
    )

    dataset[&#34;Xtrain&#34;] = Xtrain
    dataset[&#34;Xvalid&#34;] = Xvalid
    dataset[&#34;ytrain&#34;] = ytrain
    dataset[&#34;yvalid&#34;] = yvalid
    return dataset</code></pre>
</details>
</dd>
<dt id="src.features.build_features.times_2_cycles"><code class="name flex">
<span>def <span class="ident">times_2_cycles</span></span>(<span>df: pandas.core.frame.DataFrame, time_types: List[str] = ['doy']) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Converts some times to a cyclic axis of x, y using sin and cos. </p>
<ol>
<li>Converts the times to radians </li>
<li>Normalizes by the maximum of the time cycle</li>
<li>Applies the sin and cosine transformation</li>
<li>Drops original columns</li>
</ol>
<h2 id="parameters">Parameters</h2>
<p>df : pd.DataFrame
A dataframe with the values. The columns need to be one of the following
['doy', 'month', 'hour']</p>
<p>time_types : List of , e.g. ['doy', 'month', 'hour']
The time type to convert to a cycle
doy - assumes 1 in 24 hours</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A dataframe with the converted values.</dd>
</dl>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<p>times = ['doy']
df = time_2_cycle(df, times)</p>
<p>times = ['doy', 'month']
df = times_2_cycles(df, times)</p>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def times_2_cycles(df: pd.DataFrame, time_types: List[str] = [&#34;doy&#34;]) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Converts some times to a cyclic axis of x, y using sin and cos. 
    
    
    1. Converts the times to radians 
    2. Normalizes by the maximum of the time cycle
    3. Applies the sin and cosine transformation
    4. Drops original columns

    Parameters 
    ----------
    df : pd.DataFrame
        A dataframe with the values. The columns need to be one of the following
        [&#39;doy&#39;, &#39;month&#39;, &#39;hour&#39;]
    
    time_types : List of , e.g. [&#39;doy&#39;, &#39;month&#39;, &#39;hour&#39;]
        The time type to convert to a cycle
        doy - assumes 1 in 24 hours
    
    Returns
    -------
    df : pd.DataFrame
        A dataframe with the converted values.

    Example
    -------
    &gt;&gt; times = [&#39;doy&#39;]
    &gt;&gt; df = time_2_cycle(df, times)

    &gt;&gt; times = [&#39;doy&#39;, &#39;month&#39;]
    &gt;&gt; df = times_2_cycles(df, times)
    &#34;&#34;&#34;
    deg2rad = 2 * np.pi

    cols = X.columns.tolist()

    if &#34;doy&#34; in time_types and &#34;doy&#34; in cols:

        const = 365.0  # number of days in a year

        df[&#34;doy_sin&#34;] = np.sin(df[&#34;doy&#34;] * deg2rad / const)
        df[&#34;doy_cos&#34;] = np.cos(df[&#34;doy&#34;] * deg2rad / const)

        df = df.drop(&#34;doy&#34;, axis=1)

    if &#34;month&#34; in time_types and &#34;month&#34; in cols:

        const = 12  # number of months in a year

        df[&#34;month_sin&#34;] = np.sin((df[&#34;month&#34;] - 1) * deg2rad / const)
        df[&#34;month_cos&#34;] = np.cos((df[&#34;month&#34;] - 1) * deg2rad / const)

        df = df.drop(&#34;month&#34;, axis=1)

    if &#34;hour&#34; in time_types and &#34;hour&#34; in cols:

        const = 24.0  # number of days in a year

        df[&#34;hour_sin&#34;] = np.sin(df[&#34;hour&#34;] * deg2rad / const)
        df[&#34;hour_cos&#34;] = np.cos(df[&#34;hour&#34;] * deg2rad / const)

        df = df.drop(&#34;hour&#34;, axis=1)

    # drop original column

    return df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.features.build_features.CycleTransform"><code class="flex name class">
<span>class <span class="ident">CycleTransform</span></span>
<span>(</span><span>time_types: List[str] = ['doy'])</span>
</code></dt>
<dd>
<div class="desc"><p>Converts some times to a cyclic axis of x, y using sin and cos. </p>
<ol>
<li>Converts the times to radians </li>
<li>Normalizes by the maximum of the time cycle</li>
<li>Applies the sin and cosine transformation</li>
<li>Drops original columns</li>
</ol>
<h2 id="parameters">Parameters</h2>
<p>time_types : List of , e.g. ['doy', 'month', 'hour']
The time type to convert to a cycle
doy - assumes 1 in 24 hours</p>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<p>times = ['doy']
X = CycleTransform(times).fit_transform(X)</p>
<p>times = ['doy', 'month']
X = CycleTransform(times).fit_transform(X)</p>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CycleTransform(BaseEstimator, TransformerMixin):
    &#34;&#34;&#34;Converts some times to a cyclic axis of x, y using sin and cos. 
    
    
    1. Converts the times to radians 
    2. Normalizes by the maximum of the time cycle
    3. Applies the sin and cosine transformation
    4. Drops original columns

    Parameters 
    ----------
    time_types : List of , e.g. [&#39;doy&#39;, &#39;month&#39;, &#39;hour&#39;]
        The time type to convert to a cycle
        doy - assumes 1 in 24 hours

    Example
    -------
    &gt;&gt; times = [&#39;doy&#39;]
    &gt;&gt; X = CycleTransform(times).fit_transform(X)

    &gt;&gt; times = [&#39;doy&#39;, &#39;month&#39;]
    &gt;&gt; X = CycleTransform(times).fit_transform(X)
    &#34;&#34;&#34;

    def __init__(self, time_types: List[str] = [&#34;doy&#34;]):
        self.time_types = time_types

    def fit(self, X, y=None):
        &#34;&#34;&#34;For compatibility reasons.&#34;&#34;&#34;
        return self

    def transform(self, X: pd.DataFrame, y: Optional[pd.DataFrame] = None):
        &#34;&#34;&#34;
        Parameters 
        ----------
        X : pd.DataFrame
            A dataframe with the values. The columns need to be one of the following
            [&#39;doy&#39;, &#39;month&#39;, &#39;hour&#39;]
        
        y : pd.DataFrame, Optional
            Does nothing. Only for compatibility reasons.
        
        Returns
        -------
        df : pd.DataFrame
            A dataframe with the converted values.
        &#34;&#34;&#34;
        deg2rad = 2 * np.pi

        cols = X.columns.tolist()

        if &#34;doy&#34; in self.time_types and &#34;doy&#34; in cols:

            const = 365.0  # number of days in a year

            X[&#34;doy_sin&#34;] = np.sin(X[&#34;doy&#34;] * deg2rad / const)
            X[&#34;doy_cos&#34;] = np.cos(X[&#34;doy&#34;] * deg2rad / const)

            X = X.drop(&#34;doy&#34;, axis=1)

        if &#34;month&#34; in self.time_types and &#34;month&#34; in cols:

            const = 12  # number of months in a year

            X[&#34;month_sin&#34;] = np.sin((X[&#34;month&#34;] - 1) * deg2rad / const)
            X[&#34;month_cos&#34;] = np.cos((X[&#34;month&#34;] - 1) * deg2rad / const)

            X = X.drop(&#34;month&#34;, axis=1)

        if &#34;hour&#34; in self.time_types and &#34;hour&#34; in cols:

            const = 24.0  # number of days in a year

            X[&#34;hour_sin&#34;] = np.sin(X[&#34;hour&#34;] * deg2rad / const)
            X[&#34;hour_cos&#34;] = np.cos(X[&#34;hour&#34;] * deg2rad / const)

            X = X.drop(&#34;hour&#34;, axis=1)

        # drop original column

        return X</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sklearn.base.BaseEstimator</li>
<li>sklearn.base.TransformerMixin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.features.build_features.CycleTransform.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, X, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>For compatibility reasons.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, X, y=None):
    &#34;&#34;&#34;For compatibility reasons.&#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="src.features.build_features.CycleTransform.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, X: pandas.core.frame.DataFrame, y: Union[pandas.core.frame.DataFrame, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<p>X : pd.DataFrame
A dataframe with the values. The columns need to be one of the following
['doy', 'month', 'hour']</p>
<p>y : pd.DataFrame, Optional
Does nothing. Only for compatibility reasons.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A dataframe with the converted values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, X: pd.DataFrame, y: Optional[pd.DataFrame] = None):
    &#34;&#34;&#34;
    Parameters 
    ----------
    X : pd.DataFrame
        A dataframe with the values. The columns need to be one of the following
        [&#39;doy&#39;, &#39;month&#39;, &#39;hour&#39;]
    
    y : pd.DataFrame, Optional
        Does nothing. Only for compatibility reasons.
    
    Returns
    -------
    df : pd.DataFrame
        A dataframe with the converted values.
    &#34;&#34;&#34;
    deg2rad = 2 * np.pi

    cols = X.columns.tolist()

    if &#34;doy&#34; in self.time_types and &#34;doy&#34; in cols:

        const = 365.0  # number of days in a year

        X[&#34;doy_sin&#34;] = np.sin(X[&#34;doy&#34;] * deg2rad / const)
        X[&#34;doy_cos&#34;] = np.cos(X[&#34;doy&#34;] * deg2rad / const)

        X = X.drop(&#34;doy&#34;, axis=1)

    if &#34;month&#34; in self.time_types and &#34;month&#34; in cols:

        const = 12  # number of months in a year

        X[&#34;month_sin&#34;] = np.sin((X[&#34;month&#34;] - 1) * deg2rad / const)
        X[&#34;month_cos&#34;] = np.cos((X[&#34;month&#34;] - 1) * deg2rad / const)

        X = X.drop(&#34;month&#34;, axis=1)

    if &#34;hour&#34; in self.time_types and &#34;hour&#34; in cols:

        const = 24.0  # number of days in a year

        X[&#34;hour_sin&#34;] = np.sin(X[&#34;hour&#34;] * deg2rad / const)
        X[&#34;hour_cos&#34;] = np.cos(X[&#34;hour&#34;] * deg2rad / const)

        X = X.drop(&#34;hour&#34;, axis=1)

    # drop original column

    return X</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.features.build_features.GeoCartTransform"><code class="flex name class">
<span>class <span class="ident">GeoCartTransform</span></span>
</code></dt>
<dd>
<div class="desc"><p>Transforms geo coordinates (lat, lon) to cartesian coordinates
(x, y, z).</p>
<h2 id="example">Example</h2>
<blockquote>
<blockquote>
<p>df = geo_2_cartesian(df)</p>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeoCartTransform(BaseEstimator, TransformerMixin):
    &#34;&#34;&#34;Transforms geo coordinates (lat, lon) to cartesian coordinates
    (x, y, z).
    
    Example
    -------
    &gt;&gt; df = geo_2_cartesian(df)
    &#34;&#34;&#34;

    def __init__(self):
        pass

    def fit(self, X: pd.DataFrame, y: Optional[pd.DataFrame] = None):
        return self

    def transform(self, X: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34;    
        Parameters 
        ----------
        df : pd.DataFrame
            A dataframe with the geo coordinates values. The columns need to 
            have the following [&#39;lat&#39;, &#39;lon]
        
        Returns
        -------
        df : pd.DataFrame
            A dataframe with the converted values.
        &#34;&#34;&#34;
        cols = X.columns.tolist()

        if &#34;lat&#34; not in cols or &#34;lon&#34; not in cols:
            print(&#34;lat,lon columns not present in X.&#34;)
            return X

        deg2rad = np.pi / 180.0

        # transform from degrees to radians
        X[&#34;lat&#34;] *= deg2rad
        X[&#34;lon&#34;] *= deg2rad

        # From Geo coords to cartesian coords
        X[&#34;x&#34;] = np.cos(X[&#34;lat&#34;]) * np.cos(X[&#34;lon&#34;])
        X[&#34;y&#34;] = np.cos(X[&#34;lat&#34;]) * np.sin(X[&#34;lon&#34;])
        X[&#34;z&#34;] = np.sin(X[&#34;lat&#34;])

        # drop original columns
        X = X.drop([&#34;lat&#34;, &#34;lon&#34;], axis=1)

        return X</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sklearn.base.BaseEstimator</li>
<li>sklearn.base.TransformerMixin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.features.build_features.GeoCartTransform.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, X: pandas.core.frame.DataFrame, y: Union[pandas.core.frame.DataFrame, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, X: pd.DataFrame, y: Optional[pd.DataFrame] = None):
    return self</code></pre>
</details>
</dd>
<dt id="src.features.build_features.GeoCartTransform.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, X: pandas.core.frame.DataFrame) -> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<p>df : pd.DataFrame
A dataframe with the geo coordinates values. The columns need to
have the following ['lat', 'lon]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A dataframe with the converted values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, X: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;    
    Parameters 
    ----------
    df : pd.DataFrame
        A dataframe with the geo coordinates values. The columns need to 
        have the following [&#39;lat&#39;, &#39;lon]
    
    Returns
    -------
    df : pd.DataFrame
        A dataframe with the converted values.
    &#34;&#34;&#34;
    cols = X.columns.tolist()

    if &#34;lat&#34; not in cols or &#34;lon&#34; not in cols:
        print(&#34;lat,lon columns not present in X.&#34;)
        return X

    deg2rad = np.pi / 180.0

    # transform from degrees to radians
    X[&#34;lat&#34;] *= deg2rad
    X[&#34;lon&#34;] *= deg2rad

    # From Geo coords to cartesian coords
    X[&#34;x&#34;] = np.cos(X[&#34;lat&#34;]) * np.cos(X[&#34;lon&#34;])
    X[&#34;y&#34;] = np.cos(X[&#34;lat&#34;]) * np.sin(X[&#34;lon&#34;])
    X[&#34;z&#34;] = np.sin(X[&#34;lat&#34;])

    # drop original columns
    X = X.drop([&#34;lat&#34;, &#34;lon&#34;], axis=1)

    return X</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.features.build_features.ProcessParams"><code class="flex name class">
<span>class <span class="ident">ProcessParams</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessParams:
    n_components = 5
    valid_split = 0.2
    standardize = &#34;before&#34;
    seed = 123
    bootstrap_seed = 123</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.features.build_features.ProcessParams.bootstrap_seed"><code class="name">var <span class="ident">bootstrap_seed</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.features.build_features.ProcessParams.n_components"><code class="name">var <span class="ident">n_components</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.features.build_features.ProcessParams.seed"><code class="name">var <span class="ident">seed</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.features.build_features.ProcessParams.standardize"><code class="name">var <span class="ident">standardize</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.features.build_features.ProcessParams.valid_split"><code class="name">var <span class="ident">valid_split</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.features" href="index.html">src.features</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.features.build_features.geo_2_cartesian" href="#src.features.build_features.geo_2_cartesian">geo_2_cartesian</a></code></li>
<li><code><a title="src.features.build_features.get_geodataframe" href="#src.features.build_features.get_geodataframe">get_geodataframe</a></code></li>
<li><code><a title="src.features.build_features.run_input_postprocess" href="#src.features.build_features.run_input_postprocess">run_input_postprocess</a></code></li>
<li><code><a title="src.features.build_features.run_input_preprocess" href="#src.features.build_features.run_input_preprocess">run_input_preprocess</a></code></li>
<li><code><a title="src.features.build_features.run_output_postprocess" href="#src.features.build_features.run_output_postprocess">run_output_postprocess</a></code></li>
<li><code><a title="src.features.build_features.run_output_preprocess" href="#src.features.build_features.run_output_preprocess">run_output_preprocess</a></code></li>
<li><code><a title="src.features.build_features.run_split" href="#src.features.build_features.run_split">run_split</a></code></li>
<li><code><a title="src.features.build_features.times_2_cycles" href="#src.features.build_features.times_2_cycles">times_2_cycles</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.features.build_features.CycleTransform" href="#src.features.build_features.CycleTransform">CycleTransform</a></code></h4>
<ul class="">
<li><code><a title="src.features.build_features.CycleTransform.fit" href="#src.features.build_features.CycleTransform.fit">fit</a></code></li>
<li><code><a title="src.features.build_features.CycleTransform.transform" href="#src.features.build_features.CycleTransform.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.features.build_features.GeoCartTransform" href="#src.features.build_features.GeoCartTransform">GeoCartTransform</a></code></h4>
<ul class="">
<li><code><a title="src.features.build_features.GeoCartTransform.fit" href="#src.features.build_features.GeoCartTransform.fit">fit</a></code></li>
<li><code><a title="src.features.build_features.GeoCartTransform.transform" href="#src.features.build_features.GeoCartTransform.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.features.build_features.ProcessParams" href="#src.features.build_features.ProcessParams">ProcessParams</a></code></h4>
<ul class="">
<li><code><a title="src.features.build_features.ProcessParams.bootstrap_seed" href="#src.features.build_features.ProcessParams.bootstrap_seed">bootstrap_seed</a></code></li>
<li><code><a title="src.features.build_features.ProcessParams.n_components" href="#src.features.build_features.ProcessParams.n_components">n_components</a></code></li>
<li><code><a title="src.features.build_features.ProcessParams.seed" href="#src.features.build_features.ProcessParams.seed">seed</a></code></li>
<li><code><a title="src.features.build_features.ProcessParams.standardize" href="#src.features.build_features.ProcessParams.standardize">standardize</a></code></li>
<li><code><a title="src.features.build_features.ProcessParams.valid_split" href="#src.features.build_features.ProcessParams.valid_split">valid_split</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>